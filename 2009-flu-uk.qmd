# Modelling the 2009 UK flu pandemic

```{r}
#| include: false
source("common.R")
```

```{r, echo=FALSE}
r_output <- function(path, highlight = NULL) {
  if (is.null(highlight)) {
    prefix <- "```r"
  } else {
    prefix <- sprintf('```{.r code-line-numbers="%s"}', highlight)
  }
  writeLines(c(prefix, readLines(path), "```"))
}
set.seed(1) # always the same
knitr::knit_hooks$set(small_margins = function(before, options, envir) {
  if (before) {
    par(mar = c(4, 4, .1, .1))
  }
})
```

This chapter explores the use of `odin` and `monty` to model the dynamics of the 2009 A/H1N1 influenza pandemic in England and Wales incorporating changes in social contacts during holiday periods. We demonstrate how to construct, fit, and analyse a compartmental model to infer key epidemiological parameters.

## Overview of the Pipeline

This chapter illustrates how to:

1. Construct an SEIR model with time-varying transmission using `odin`.
2. Implement an observation model, derive a likelihood based on observations using `odin`.
3. Run Bayesian inference using Markov chain Monte Carlo (MCMC) with `monty`.
4. Analyse and interpret MCMC results to estimate parameters such as:
   - The basic reproduction number $R_0$.  
   - The ascertainment probability, i.e., the proportion of symptomatic infections reported as cases.

```{r}
library(odin2)
library(dust2)
```

## Data Preparation

The dataset consists of weekly case estimates, stratified by age group. For simplicity, we aggregate the data into a single time series for the analysis.

## Loading data

Data is the number of weekly cases of A/H1N1 pandemic cases from June 2009, and initially broken in seven age-groups. The data file is taken from the supplement material in [@endo_introduction_2019] and can be found [here](https://github.com/akira-endo/Intro-PMCMC/blob/master/assets/andre_estimates_21_02.txt).

We will fit our model to all cases aggregated so we need to load our data, add the age-group, and then build a dataframe (a table where each rows is an observations of certains variables in the columns) with 'Days' and 'cases'. We use the `dplyr` package, a popular R package for data handling, with the '%>%' ('pipe') operator but other methods are possible.  

```{r}
library(dplyr)

# Read the data
original_data <- read.csv(file = "data/andre_estimates_21_02.txt", sep = "\t") %>% rowSums()

# Group all age groups
data <- data.frame(Cases = original_data) %>%
  mutate(Days = seq(7, by = 7, length.out = n())) %>%
  dplyr::select(Days, Cases)
```

```{r, echo=FALSE}
q_n <- 1
```

## Plotting the data

You can plot the data and see the two waves of infections and the presence of holiday periods.
```{r}
#plot the data
plot(data$Day, data$Cases, pch = 19, col = "red",
     xlab="Days since start of epidemics",
     ylab="Official cases count")

# Add the holiday periods - summer holidays and half-term
# Holiday calendar assuming 30% contact reduction during summer and 15% during half term
hol_t <- c(0,38,85,140,147)
hol_v <- c(1,.70,1,.85,1)
#summer holiday block
rect(xleft = hol_t[2],ybottom = 0, xright = hol_t[3], ytop = max(data$Cases)*1.2, col = "#aaaabb33", border = NA)
#half-term holiday block
rect(xleft = hol_t[4],ybottom = 0, xright = hol_t[5], ytop = max(data$Cases)*1.2, col = "#aaaabb33", border = NA)
```

## Understanding the model

The SEIR model divides the population into four compartments:

- **S**usceptible: Individuals at risk of infection.  
- **E**xposed: Infected individuals who are not yet infectious.  
- **I**nfectious: Actively transmitting the disease.  
- **R**ecovered: Immune individuals.  

The model incorporates time-varying transmission rates to account for changes in contact patterns during holidays. Using `odin`, we define this system of differential equations:

## Compiling the model

The model needs to be transpiled (e.g. translated from one programming language to another) in order to create some C++ code. That code is then compiled and loaded to create a "fast" model that can be called from the R environment. 

```{r, echo = TRUE}
seir <- odin2::odin({
# initial conditions
initial(S) <- (1 - 2 * alpha) * N
initial(E) <- alpha*N
initial(I) <- alpha*N
initial(R) <- 0
initial(incidence, zero_every = 7) <- 0

# equations
deriv(S) <- - hol * beta * S * I / N
deriv(E) <- hol * beta * S * I / N - gamma * E
deriv(I) <- gamma * E - sigma * I
deriv(R) <- sigma * I
deriv(incidence) <- gamma * E

# parameter values
R_0 <- parameter(1.5)
L <- 1
D <- 1.25
alpha <- parameter(1e-4) # initial proportion
N <- 55000000

# convert parameters
hol <- interpolate(h_times, h_values, "constant")
h_times <- parameter()
h_values <- parameter()
dim(h_times) <- parameter(rank=1)
dim(h_values) <- length(h_times)
gamma <- 1 / L
sigma <- 1 / D
beta <- R_0 * sigma})
```

## Running the model

Once the model is compiled, it is possible to generate one (or more!) instance of your model by using the `dust_system_create()` and your model generator.

```{r}
#mod <- seir$new(h_times = hol_t, h_values = hol_v)
mod <- dust_system_create(seir,
                          pars = list(h_times = hol_t, h_values = hol_v))
```

```{r}
# A vector with parameter values
# First parameter -> proportion of population initially infected
# Second argument -> R_0
# Third argument -> Proportion of infection detected 
par0 <- c(5e-5, 1.3, 0.1)

# This vector should be passed as a list
dust_system_update_pars(sys = mod,
                        pars = list(alpha=par0[1],
                                    R_0=par0[2],
                                    h_times = hol_t,
                                    h_values= hol_v))
```

Then the model can be run by specifying the time points between which to integrate the ODEs. Note that the first point (here 0) set the inital time of the integration. Once the time vector t is defined we can run the model by using the "$run(t)" method.
```{r}
t <- c(0,data$Days)
dust_system_set_state_initial(mod)
y <- dust_system_simulate(mod, t)
```

Let's plot the I compartment over time.

```{r}
plot(t, dust_unpack_state(mod, y)$incidence, type = "l", col = "red", lwd = 2)
```

It looks a bit like the actual epidemic; a good sign, but let compare our model with the data.

# Part 2. Observation model, likelihood and prior distributions

We now have a dataset and a working model, all loaded in our R environment. We need to link the output of this model with the data in order to derive a likelihood function. As we are working within a Bayesian framework we also need to define the prior distribution for our parameters. 

## Cumulative incidence and observed cases

The fundamental component of our model if the 'I' compartment tracking continuously the number of infectious people in our population (an infection prevalence). However, what we observe is a fraction of the cumulative incidence, more precisely the number of new cases in a period of 7 days (a week). In our `odin` model we track the cumulative incidence, and we have simulated it using 7 days intervals. We can thus write a simple function giving the cumulative incidence between two days:
